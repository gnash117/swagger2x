//******************************************************************
//
// Copyright 2017 Open Connectivity Foundation
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
#include <signal.h>
#include <thread>
#include <functional>

#include "server.h"
//#include "sensors.h"
#include "namedefs.h"
//using namespace Sensors;


/*
 tool_version          : {{version}}
 input_file            : {{input_file}}
 version of input_file : {{json_data['info']['version']}}
 title of input_file   : {{json_data['info']['title']}}
*/

// Set of strings for each of platform Info fields
std::string gPlatformId = "0A3E0D6F-DBF5-404E-8719-D6880042463A";
std::string gManufacturerName = "OCF";
std::string gManufacturerLink = "https://openconnectivity.org/";
std::string gModelNumber = "ModelNumber";
std::string gDateOfManufacture = "2017-12-01";
std::string gPlatformVersion = "1.0";
std::string gOperatingSystemVersion = "myOS";
std::string gHardwareVersion = "1.0";
std::string gFirmwareVersion = "1.0";
std::string gSupportLink = "https://openconnectivity.org/";
std::string gSystemTime = "2017-12-01T12.00";

// Set of strings for each of device info fields
std::string  gDeviceName = "{{json_data['info']['title']}}";
std::string  gDeviceType = "oic.wk.tv";
std::string  gSpecVersion = "ocf.1.3.0";
//std::vector<std::string> gDataModelVersions = {"ocf.res.1.1.0", "ocf.sh.1.1.0"};
std::vector<std::string> gDataModelVersions = {"ocf.res.1.3.0", "ocf.dev.1.3.0"};
std::string  gProtocolIndependentID = "fa008167-3bbf-4c9d-8604-c9bcb96cb712";


/**
*  DuplicateString
*
* @param targetString  destination string, will be allocated
* @param sourceString  soruce string, e.g. will be copied

*  TODO: don't use strncpy
*/
void DuplicateString(char ** targetString, std::string sourceString)
{
    *targetString = new char[sourceString.length() + 1];
    strncpy(*targetString, sourceString.c_str(), (sourceString.length() + 1));
}


/**
*  intialize platform
*  TODO: put here the security and introspection loading
*/
void IoTServer::initializePlatform()
{
    cout << "Running initializePlatform" << endl;
    m_platformConfig = make_shared<PlatformConfig>(ServiceType::InProc, ModeType::Server, "0.0.0.0",
                                                   0, OC::QualityOfService::HighQos);
    OCPlatform::Configure(*m_platformConfig);
    
    // initialize "oic/p"
    OCStackResult result = SetPlatformInfo(gPlatformId, gManufacturerName, gManufacturerLink,
            gModelNumber, gDateOfManufacture, gPlatformVersion, gOperatingSystemVersion,
            gHardwareVersion, gFirmwareVersion, gSupportLink, gSystemTime);
    result = OCPlatform::registerPlatformInfo(m_platformInfo);
    if (result != OC_STACK_OK)
    {
        std::cout << "Platform Registration (oic/p) failed\n";
    }
    
    // initialize "oic/d"
    result = SetDeviceInfo();
    if (result != OC_STACK_OK)
    {
        std::cout << "Device Registration (oic/p) failed\n";
    }
}

/**
*  constructor
*
*/
IoTServer::IoTServer()
{
    cout << "Running IoTServer constructor" << endl;
    initializePlatform();
    setupResources();  
}

/**
*  destructor
*
*/
IoTServer::~IoTServer()
{
    cout << "Running IoTServer destructor" << endl;
    //ClosePins();
    
    DeletePlatformInfo();
}

/**
*  method to setup all the resources.
*
*/
void IoTServer::setupResources()
{
    cout << "Running setupResources" << endl;
{%- for path, path_data in json_data['paths'].items() -%}    
    EntityHandler cb1 = bind(&IoTServer::f{{path|variablesyntax}}EntityHandler, this, placeholders::_1);
    createResource( m{{path|variablesyntax}}_RESOURCE_ENDPOINT, 
                    m{{path|variablesyntax}}_RESOURCE_TYPE[0], 
                    m{{path|variablesyntax}}_RESOURCE_INTERFACE[0], cb1,
                    m{{path|variablesyntax}}ResourceHandle);
    IoTObserverCb temp{{path|variablesyntax}}Cb = bind(&IoTServer::f{{path|variablesyntax}}ObserverLoopFunc, this);
    m{{path|variablesyntax}}ObserverLoop = make_shared<IoTObserver>(temp{{path|variablesyntax}}Cb);
    // add the additional interfaces
    for( unsigned int a = 1; a < sizeof(m{{path|variablesyntax}}_RESOURCE_INTERFACE); a++ )
    {
        OCStackResult result = OCBindResourceInterfaceToResource(m{{path|variablesyntax}}ResourceHandle, m{{path|variablesyntax}}_RESOURCE_INTERFACE[a]);
        if (result != OC_STACK_OK)
            cerr << "Could not bind interface:" << m{{path|variablesyntax}}_RESOURCE_INTERFACE[a] << endl;
    }
    // add the additional resource types
    for( unsigned int a = 1; a < sizeof(m{{path|variablesyntax}}_RESOURCE_TYPE); a++1 )
    {
        OCStackResult result = OCBindResourceTypeToResource(m{{path|variablesyntax}}ResourceHandle, m{{path|variablesyntax}}_RESOURCE_TYPE[a]);
        if (result != OC_STACK_OK)
            cerr << "Could not bind resource type:" << m{{path|variablesyntax}}_RESOURCE_INTERFACE[a] << endl;
    }
 
    // initialize member variables for each resource{% for path, path_data in json_data['paths'].items() %}
    // initialize member variables {{path}}{% for var, var_data in query_properties(json_data, path).items() -%}
{% if var_data.type == "number" %} 
    m{{path|variablesyntax}}{{var|variablesyntax}} = 0.0; // current value of property "{{var}}" {% endif -%}
{% if var_data.type == "integer" %} 
    m{{path|variablesyntax}}{{var|variablesyntax}} = 0; // current value of property "{{var}}" {% endif -%}
{% if var_data.type == "string" %} 
    m{{path|variablesyntax}}{{var|variablesyntax}} = "";  // current value of property "{{var}}" {% endif -%} 
{% endfor %}
{% endfor %}
{% endfor %}
}

/**
*  method to create the resource.
*
* @param Uri the URI to use.
* @param Type the resource type (rt).
* @param EntityHandler the entity handler for the resource.
* @param OCResourceHandle the resource handle
*/
void IoTServer::createResource(string Uri, string Type, string resourceInterface, EntityHandler Cb, OCResourceHandle& Handle)
{
    string resourceUri = Uri;
    string resourceType = Type;
    uint8_t resourceFlag = OC_DISCOVERABLE | OC_OBSERVABLE;

    OCStackResult result = OCPlatform::registerResource(Handle, resourceUri, resourceType,
                                                        resourceInterface, Cb, resourceFlag);

    if (result != OC_STACK_OK)
        cerr << "Could not create " << Type << " resource" << endl;
    else
        cout << "Successfully created " << Type << " resource" << endl;
}

{% for path, path_data in json_data['paths'].items() -%}
/**
*  method for {{path}} to respond to all observers if something is changed
*/
void IoTServer::f{{path|variablesyntax}}ObserverLoopFunc()
{
    usleep(1500000);
    cout << "{{path}} Observer Callback" << endl;
    shared_ptr<OCResourceResponse> resourceResponse(new OCResourceResponse());
    resourceResponse->setResourceRepresentation(get{{path|variablesyntax}}Representation(),
    m{{path|variablesyntax}}_RESOURCE_INTERFACE);
    OCStackResult result = OCPlatform::notifyListOfObservers(m{{path|variablesyntax}}Resource,
                                                             m{{path|variablesyntax}}Observers,
                                                             resourceResponse);
    if (result == OC_STACK_NO_OBSERVERS)
    {
        cout << "No more observers..Stopping observer loop..." << endl;
        m{{path|variablesyntax}}ObserverLoop->stop();
    }
}
{% endfor -%}  

{% for path, path_data in json_data['paths'].items() -%}
{% for methodName, method_data in path_data.items() -%}
{% if methodName == "post" %} 
/**
*  post method for {{path}} to assign the returned values to the member values
* @param requestRep the request representation.
* TODO: this function is also referenced when only get is implemented, something to fix..
*/
OCRepresentation IoTServer::post{{path|variablesyntax}}Representation(OCRepresentation requestRep)
{
    OCEntityHandlerResult result = OC_EH_OK;  // default ok
    
    // only integer, float and string
    {% for var, var_data in query_properties(json_data, path).items() -%}
    if (requestRep.hasAttribute(m{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}))
    {
        try
        {
            cout << "IoTServer::post{{path|variablesyntax}}Representation setting: m{{path|variablesyntax}}{{var|variablesyntax}}" << endl;
        {% if var_data.type == "number" %}    m{{path|variablesyntax}}{{var|variablesyntax}} = requestRep.getValue<{{var_data.type|convert_to_c_type}}>(m{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}); {%- endif %}
        {% if var_data.type == "integer" %}    m{{path|variablesyntax}}{{var|variablesyntax}} = requestRep.getValue<{{var_data.type|convert_to_c_type}}>(m{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}); {%- endif %}
        {% if var_data.type == "string" %}    m{{path|variablesyntax}}{{var|variablesyntax}} = requestRep.getValue<{{var_data.type|convert_to_c_type}}>(m{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}); {%- endif %}
        }
        catch (...)
        {
            cerr << "Client sent invalid resource value type: " << m{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}<< endl;
            result = OC_EH_ERROR;
        }
    }
    {% endfor -%}

    return result;
}
{% endif -%}
{% endfor -%}
{% endfor -%}  



{% for path, path_data in json_data['paths'].items() -%}
{% for methodName, method_data in path_data.items() -%}
{% if methodName == "get" %} 
/**
*  get method for {{path}} to create an representation from the member values to respond to the call

*/
OCRepresentation IoTServer::get{{path|variablesyntax}}Representation()
{
    OCRepresentation rep;
    
    // Add the attribute name and values in the representation (only integer, number and string)
{% for var, var_data in query_properties(json_data, path).items() -%}
{% if var_data.type == "number" %}
    rep.setValue(m{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, m{{path|variablesyntax}}{{var|variablesyntax}} ); {% endif -%}
{% if var_data.type == "integer" %} 
    rep.setValue(m{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, m{{path|variablesyntax}}{{var|variablesyntax}} ); {% endif -%}
{% if var_data.type == "string" %} 
    rep.setValue(m{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}}, m{{path|variablesyntax}}{{var|variablesyntax}} ); {% endif -%}
{% endfor %}
       
    return rep  
}
{% endif -%}
{% endfor -%}
{% endfor %}   
 

{% for path, path_data in json_data['paths'].items() -%}
/**
*  the entity handler for {{path}}
* @param Request the incomming request for this resource to handle
*/
OCEntityHandlerResult IoTServer::f{{path|variablesyntax}}EntityHandler(shared_ptr<OCResourceRequest> Request)
{
    OCEntityHandlerResult result = OC_EH_ERROR;
    if (Request)
    {
        string requestType = Request->getRequestType();
        int requestFlag = Request->getRequestHandlerFlag();
        if (requestFlag & RequestHandlerFlag::RequestFlag)
        {
            auto Response = std::make_shared<OC::OCResourceResponse>();
            Response->setRequestHandle(Request->getRequestHandle());
            Response->setResourceHandle(Request->getResourceHandle());
{% for methodName, method_data in path_data.items() -%}
{% if methodName == "get" %} 
            if (requestType == OC_REST_GET)
            {
                cout << "GET request for {{path}} reading" << endl;
                if (Response)
                {
                    Response->setResponseResult(OC_EH_OK);
                    Response->setResourceRepresentation(get{{path|variablesyntax}}Representation());
                    if (OCPlatform::sendResponse(Response) == OC_STACK_OK)
                    {
                        result = OC_EH_OK;
                    }
                }
            } {% endif -%} {% endfor %}{% for methodName, method_data in path_data.items() -%}{% if methodName == "post" %}             
            else if (requestType == OC_REST_POST)
            {
                cout << "POST request for {{path}}" << endl;
                // post function sets the member variables correctly.
                result = Request->post{{path|variablesyntax}}Representation(requestRep);
                if (result == OC_EH_OK)
                {
                    // TODO, we might need to return something..
                    //Response->setResourceRepresentation(get{{path|variablesyntax}}Representation());
                    Response->setResponseResult(OC_EH_OK);
                    if (OCPlatform::sendResponse(Response) == OC_STACK_OK)
                    {
                        result = OC_EH_OK;
                    }
                }
                else
                {
                    Response->setResponseResult(OC_EH_ERROR);
                    OCPlatform::sendResponse(Response);
                    cerr << "Unsupported request type" << endl;
                    return result;
                }
            } {% endif -%}{% endfor %}  
            else
            {
                Response->setResponseResult(OC_EH_ERROR);
                OCPlatform::sendResponse(Response);
                cerr << "Unsupported request type" << endl;
                return result;
            }
        }
        if (requestFlag & RequestHandlerFlag::ObserverFlag)
        {
            ObservationInfo observationInfo = Request->getObservationInfo();
            if (ObserveAction::ObserveRegister == observationInfo.action)
            {
                cout << "Starting observer for {{path}}" << endl;
                m{{path|variablesyntax}}Observers.push_back(observationInfo.obsId);
                m{{path|variablesyntax}}ObserverLoop->start();
            }
            else if (ObserveAction::ObserveUnregister == observationInfo.action)
            {
                m_temperatureObservers.erase(
                        remove(m{{path|variablesyntax}}Observers.begin(), m{{path|variablesyntax}}Observers.end(),
                               observationInfo.obsId),
                        m{{path|variablesyntax}}Observers.end());
            }
        }
    }
    return result;
}
{% endfor -%}  

/**
*  DeletePlatformInfo
*  Deletes the allocated platform information
*/
void IoTServer::DeletePlatformInfo()
{
    delete[] m_platformInfo.platformID;
    delete[] m_platformInfo.manufacturerName;
    delete[] m_platformInfo.manufacturerUrl;
    delete[] m_platformInfo.modelNumber;
    delete[] m_platformInfo.dateOfManufacture;
    delete[] m_platformInfo.platformVersion;
    delete[] m_platformInfo.operatingSystemVersion;
    delete[] m_platformInfo.hardwareVersion;
    delete[] m_platformInfo.firmwareVersion;
    delete[] m_platformInfo.supportUrl;
    delete[] m_platformInfo.systemTime;
}

/**
*  SetPlatformInfo 
*  Sets the platform information ("oic/p"), from the globals

* @param platformID the platformID
* @param manufacturerName the manufacturerName
* @param manufacturerUrl the manufacturerUrl
* @param modelNumber the modelNumber
* @param platformVersion the platformVersion
* @param operatingSystemVersion the operatingSystemVersion
* @param hardwareVersion the hardwareVersion
* @param firmwareVersion the firmwareVersion
* @param supportUrl the supportUrl
* @param systemTime the systemTime
*/
OCStackResult IoTServer::SetPlatformInfo(std::string platformID, std::string manufacturerName,
        std::string manufacturerUrl, std::string modelNumber, std::string dateOfManufacture,
        std::string platformVersion, std::string operatingSystemVersion,
        std::string hardwareVersion, std::string firmwareVersion, std::string supportUrl,
        std::string systemTime)
{
    DuplicateString(&m_platformInfo.platformID, platformID);
    DuplicateString(&m_platformInfo.manufacturerName, manufacturerName);
    DuplicateString(&m_platformInfo.manufacturerUrl, manufacturerUrl);
    DuplicateString(&m_platformInfo.modelNumber, modelNumber);
    DuplicateString(&m_platformInfo.dateOfManufacture, dateOfManufacture);
    DuplicateString(&m_platformInfo.platformVersion, platformVersion);
    DuplicateString(&m_platformInfo.operatingSystemVersion, operatingSystemVersion);
    DuplicateString(&m_platformInfo.hardwareVersion, hardwareVersion);
    DuplicateString(&m_platformInfo.firmwareVersion, firmwareVersion);
    DuplicateString(&m_platformInfo.supportUrl, supportUrl);
    DuplicateString(&m_platformInfo.systemTime, systemTime);

    return OC_STACK_OK;
}

/**
*  SetDeviceInfo
*  Sets the device information ("oic/d"), from the globals
*/
OCStackResult IoTServer::SetDeviceInfo()
{
    OCStackResult result = OC_STACK_ERROR;

    OCResourceHandle handle = OCGetResourceHandleAtUri(OC_RSRVD_DEVICE_URI);
    if (handle == NULL)
    {
        cout << "Failed to find resource " << OC_RSRVD_DEVICE_URI << endl;
        return result;
    }

    result = OCBindResourceTypeToResource(handle, gDeviceType.c_str());
    if (result != OC_STACK_OK)
    {
        cout << "Failed to add device type" << endl;
        return result;
    }

    result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DEVICE_NAME, gDeviceName);
    if (result != OC_STACK_OK)
    {
        cout << "Failed to set device name" << endl;
        return result;
    }

    result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_DATA_MODEL_VERSION,
                                          gDataModelVersions);
    if (result != OC_STACK_OK)
    {
        cout << "Failed to set data model versions" << endl;
        return result;
    }

    result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_SPEC_VERSION, gSpecVersion);
    if (result != OC_STACK_OK)
    {
        cout << "Failed to set spec version" << endl;
        return result;
    }

    result = OCPlatform::setPropertyValue(PAYLOAD_TYPE_DEVICE, OC_RSRVD_PROTOCOL_INDEPENDENT_ID,
                                          gProtocolIndependentID);
    if (result != OC_STACK_OK)
    {
        cout << "Failed to set piid" << endl;
        return result;
    }

    return OC_STACK_OK;
}




// global needs static, otherwise it can be compiled out and then Ctrl-C does not work
static int quit = 0;
// handler for the signal to stop the application
void handle_signal(int signal)
{
    quit = 1;
}

// main application
// starts the server 
int main()
{
    struct sigaction sa;
    sigfillset(&sa.sa_mask);
    sa.sa_flags = 0;
    sa.sa_handler = handle_signal;
    sigaction(SIGINT, &sa, NULL);
    cout << "Press Ctrl-C to quit...." << endl;
    // create the server
    IoTServer server;
    do
    {
        usleep(2000000);
    }
    while (quit != 1);
    // delete the server
    delete IoTServer;
    
    return 0;
}

