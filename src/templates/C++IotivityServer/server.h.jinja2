//******************************************************************
//
// Copyright 2017 Open Connectivity Foundation
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
//-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=

#ifndef SERVER_H_
#define SERVER_H_

#include <string>
#include <iostream>
#include <memory>
#include "ocstack.h"
#include "observer.h"
#include "OCPlatform.h"
#include "OCApi.h"

/*
 tool_version          : {{version}}
 input_file            : {{input_file}}
 version of input_file : {{json_data['info']['version']}}
 title of input_file   : {{json_data['info']['title']}}
 
 
 typical device resource tree
 
 |-- oic/res
 |
 |-- oic/p
 |-- oic/d
 |-- virtual security resources
 |
 |-- resource-1
 .
 |-- resource-n
 
 content of oic/res is determined by the resources that are tagged with OC_DISCOVERABLE
 oic/p : content is determined by the globals in the cpp file
 oic/d : content is determined by the globals in the cpp file
 
*/

using namespace std;
using namespace OC;

class IoTServer
{

{% for path, path_data in json_data['paths'].items() -%}
    // path: {{path}}
    // the resource representation
    OCRepresentation m{{path|variablesyntax}}Representation;
    // the resource handle
    OCResourceHandle m{{path|variablesyntax}}ResourceHandle;
    // the list of observers
    ObservationIds m{{path|variablesyntax}}Observers;
    // the list of observers
    shared_ptr<IoTObserver> m{{path|variablesyntax}}ObserverLoop;
    /**
    *  method for /TemperatureResURI to respond to all observers if something is changed
    */
    void f{{path|variablesyntax}}ObserverLoopFunc();
    /**
    *  The entity handler for {{path}}
    * @param Request the request representation.
    */
    OCEntityHandlerResult f{{path|variablesyntax}}EntityHandler(shared_ptr<OCResourceRequest> Request);
{% for methodName, method_data in path_data.items() -%}
{% if methodName == "get" %} 
    /**
    *  get method for {{path}} to assign the values to be returned
    * @param requestRep the request representation.
    */
    OCRepresentation get{{path|variablesyntax}}Representation(OCRepresentation requestRep);
{% endif -%}
{% if methodName == "post" %} 
    /**
    *  post method for {{path}} to assign the request values to the member values
    * @param requestRep the request representation.
    */
    OCRepresentation post{{path|variablesyntax}}Representation(OCRepresentation requestRep);
{% endif -%}
{% endfor -%}
{% endfor %}

    // variables for the resources
{% for path, path_data in json_data['paths'].items() %}
    static string m{{path|variablesyntax}}_RESOURCE_ENDPOINT = "{{path}}";  // used path for this resource
    static string m{{path|variablesyntax}}_RESOURCE_TYPE[] = {{query_rt(json_data, path)|convert_to_c_type_array}}; // rt value (as an array)
    static string m{{path|variablesyntax}}_RESOURCE_INTERFACE[] = {{query_if(json_data, path)|convert_to_c_type_array}}; // interface if (as an array) 
{% endfor -%}
{% for path, path_data in json_data['paths'].items() %}
    // membervariables for path: {{path}}{% for var, var_data in query_properties(json_data, path).items() %}
    static string m{{path|variablesyntax}}_RESOURCE_PROPERTY_NAME{{var|variablesyntax}} = "{{var}}"; // the name for the attribute
    {{var_data.type|convert_to_c_type}} m{{path|variablesyntax}}{{var|variablesyntax}}; // the value for the attribute {% endfor -%}
{% endfor -%}    

    // OCPlatformInfo Contains all the platform info to be stored
    OCPlatformInfo m_platformInfo;
    // the platform
    shared_ptr<PlatformConfig> m_platformConfig;
    
    /**
    *  intialize the platform
    */
    void initializePlatform();
    
    /**
    *  set up the resources
    */
    void setupResources();
    
    /**
    *  create Resource
    *  helper function used in initializePlatform()
    * @param Uri the URI of the resource, must be unique
    * @param Type the resource type (rt), the first one
    * @param resourceInterface the resource inteface (if), the first one
    * @param Cb the entity handler, to handle an incomming request for this resource
    * @param Handle the resourceHandle
    */
    void createResource(string Uri, string Type, string resourceInterface, EntityHandler Cb, OCResourceHandle& Handle);
    
    /**
    *  delete the platform information
    */
    void DeletePlatformInfo();
    
    /**
    *  set the platform information
    * @param platformID the platformID
    * @param manufacturerName the manufacturerName
    * @param manufacturerUrl the manufacturerUrl
    * @param modelNumber the modelNumber
    * @param platformVersion the platformVersion
    * @param operatingSystemVersion the operatingSystemVersion
    * @param hardwareVersion the hardwareVersion
    * @param firmwareVersion the firmwareVersion
    * @param supportUrl the supportUrl
    * @param systemTime the systemTime
    */
    OCStackResult SetPlatformInfo(std::string platformID, std::string manufacturerName,
        std::string manufacturerUrl, std::string modelNumber, std::string dateOfManufacture,
        std::string platformVersion, std::string operatingSystemVersion,
        std::string hardwareVersion, std::string firmwareVersion, std::string supportUrl,
        std::string systemTime);
      
    /**
    *  set the device information
    */    
    OCStackResult SetDeviceInfo();

public:
    IoTServer();
    virtual ~IoTServer();
};

#endif /* SERVER_H_ */
